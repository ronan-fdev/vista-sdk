/*
 * MIT License
 *
 * Copyright (c) 2025 DNV
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @file VisVersionsGenerator.cpp
 * @brief VIS version header generator tool
 * @details Generates VisVersions.h (public API) and VisVersionsExtensions.h (internal utilities) from embedded VIS resource files
 */

#include <EmbeddedResource.h>

#include <nfx/string/StringBuilder.h>

#include <algorithm>
#include <cstdio>
#include <filesystem>
#include <fstream>
#include <string>
#include <vector>

namespace fs = std::filesystem;

using namespace dnv::vista::sdk;

static void writeMitLicenseHeader( nfx::string::StringBuilder& sb )
{
	sb.append( "/*\n" );
	sb.append( " * MIT License\n" );
	sb.append( " *\n" );
	sb.append( " * Copyright (c) 2025 DNV\n" );
	sb.append( " *\n" );
	sb.append( " * Permission is hereby granted, free of charge, to any person obtaining a copy\n" );
	sb.append( " * of this software and associated documentation files (the \"Software\"), to deal\n" );
	sb.append( " * in the Software without restriction, including without limitation the rights\n" );
	sb.append( " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n" );
	sb.append( " * copies of the Software, and to permit persons to whom the Software is\n" );
	sb.append( " * furnished to do so, subject to the following conditions:\n" );
	sb.append( " *\n" );
	sb.append( " * The above copyright notice and this permission notice shall be included in all\n" );
	sb.append( " * copies or substantial portions of the Software.\n" );
	sb.append( " *\n" );
	sb.append( " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n" );
	sb.append( " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n" );
	sb.append( " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n" );
	sb.append( " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n" );
	sb.append( " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n" );
	sb.append( " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n" );
	sb.append( " * SOFTWARE.\n" );
	sb.append( " */\n" );
	sb.append( "\n" );
}

static bool generateVisVersionHeader( const std::vector<std::string>& versions, const fs::path& outputPath, std::string_view sdkVersion )
{
	auto sb = nfx::string::StringBuilder( 8192 );

	writeMitLicenseHeader( sb );

	sb.append( "/**\n" );
	sb.append( " * @file VisVersions.h\n" );
	sb.append( " * @brief Type-safe enumeration of VIS versions\n" );
	sb.append( " * @details AUTO-GENERATED FILE - DO NOT EDIT - " );
	std::format_to( std::back_inserter( sb ), "Generated by: VisVersionsGenerator (vista-sdk-cpp v{})\n", sdkVersion );
	sb.append( " */\n" );
	sb.append( "\n" );

	// Includes
	sb.append( "#pragma once\n\n" );
	sb.append( "#include <cstdint>\n" );
	sb.append( "#include <optional>\n" );
	sb.append( "#include <stdexcept>\n" );
	sb.append( "#include <string_view>\n\n" );
	sb.append( "namespace dnv::vista::sdk\n" );
	sb.append( "{\n" );

	// Enum declaration
	sb.append( "/**\n" );
	sb.append( " * @brief Enumeration of VIS versions\n" );
	sb.append( " */\n" );
	sb.append( "enum class VisVersion : std::uint8_t\n" );
	sb.append( "{\n" );
	for ( const auto& version : versions )
	{
		std::string enumName = version;
		std::replace( enumName.begin(), enumName.end(), '-', '_' );
		std::format_to( std::back_inserter( sb ), "v{},\n", enumName );
	}
	sb.append( "};\n" );

	// VisVersions namespace with conversion functions
	sb.append( "/**\n" );
	sb.append( " * @brief VIS version utilities\n" );
	sb.append( " */\n" );
	sb.append( "namespace VisVersions\n" );
	sb.append( "{\n" );

	// toString function
	sb.append( "/**\n" );
	sb.append( " * @brief Convert a VisVersion to its string representation\n" );
	sb.append( " * @param version The VisVersion enum value to convert\n" );
	sb.append( " * @return String representation of the version\n" );
	sb.append( " */\n" );
	sb.append( "constexpr std::string_view toString( VisVersion version )\n" );
	sb.append( "{\n" );
	sb.append( "switch ( version )\n" );
	sb.append( "{\n" );
	for ( const auto& version : versions )
	{
		std::string enumName = version;
		std::replace( enumName.begin(), enumName.end(), '-', '_' );
		std::format_to( std::back_inserter( sb ), "case VisVersion::v{}:\n", enumName );
		sb.append( "{" );
		std::format_to( std::back_inserter( sb ), "return \"{}\";", version );
		sb.append( "}" );
	}
	sb.append( "default:\n" );
	sb.append( "throw std::invalid_argument( \"Invalid VisVersion enum value\" );\n" );
	sb.append( "}\n" );
	sb.append( "}\n" );

	// fromString function with out-parameter
	sb.append( "/**\n" );
	sb.append( " * @brief Parse string to VisVersion enum value\n" );
	sb.append( " * @details Converts string representation to enum value (e.g., \"3-9a\" -> VisVersion::v3_9a)\n" );
	sb.append( " * @param version String representation of the version (e.g., \"3-9a\")\n" );
	sb.append( " * @param result Reference to store the parsed VisVersion enum value if successful\n" );
	sb.append( " * @return true if parsing succeeded, false otherwise\n" );
	sb.append( " * @note This function is marked [[nodiscard]] - the return value should not be ignored\n" );
	sb.append( " */\n" );
	sb.append( "[[nodiscard]] constexpr bool fromString( std::string_view version, VisVersion& result ) noexcept\n" );
	sb.append( "{\n" );
	for ( const auto& version : versions )
	{
		std::string enumName = version;
		std::replace( enumName.begin(), enumName.end(), '-', '_' );
		std::format_to( std::back_inserter( sb ), "if ( version == \"{}\" )\n", version );
		sb.append( "{\n" );
		std::format_to( std::back_inserter( sb ), "result = VisVersion::v{};\n", enumName );
		sb.append( "return true;\n" );
		sb.append( "}\n" );
	}
	sb.append( "return false;\n" );
	sb.append( "}\n" );

	// fromString function with std::optional return
	sb.append( "/**\n" );
	sb.append( " * @brief Parse string to VisVersion (optional return overload)\n" );
	sb.append( " * @details Converts string representation to enum value (e.g., \"3-9a\" -> VisVersion::v3_9a)\n" );
	sb.append( " * @param version String representation of the version (e.g., \"3-9a\")\n" );
	sb.append( " * @return Optional containing VisVersion if successful, std::nullopt otherwise\n" );
	sb.append( " * @note This function is marked [[nodiscard]] - the return value should not be ignored\n" );
	sb.append( " */\n" );
	sb.append( "[[nodiscard]] constexpr std::optional<VisVersion> fromString( std::string_view version ) noexcept\n" );
	sb.append( "{\n" );
	for ( const auto& version : versions )
	{
		std::string enumName = version;
		std::replace( enumName.begin(), enumName.end(), '-', '_' );
		std::format_to( std::back_inserter( sb ), "if ( version == \"{}\" )\n", version );
		sb.append( "{\n" );
		std::format_to( std::back_inserter( sb ), "return VisVersion::v{};\n", enumName );
		sb.append( "}\n" );
	}
	sb.append( "return std::nullopt;\n" );
	sb.append( "}\n" );

	// close namespaces
	sb.append( "} // namespace VisVersions\n" );
	sb.append( "} // namespace dnv::vista::sdk\n" );

	std::ofstream outputFile( outputPath, std::ios::binary );
	if ( !outputFile )
	{
		fprintf( stderr, "Failed to open output file: %s\n", outputPath.string().c_str() );
		return false;
	}

	outputFile.write( sb.data(), static_cast<std::streamsize>( sb.size() ) );

	if ( !outputFile )
	{
		fprintf( stderr, "Failed to write to output file: %s\n", outputPath.string().c_str() );
		return false;
	}

	return true;
}

static bool generateVisVersionExtensionsHeader( const std::vector<std::string>& versions, const fs::path& outputPath, std::string_view sdkVersion )
{
	auto sb = nfx::string::StringBuilder( 8192 );

	writeMitLicenseHeader( sb );

	sb.append( "/**\n" );
	sb.append( " * @file VisVersionsExtensions.h\n" );
	sb.append( " * @brief Internal VIS version utilities for SDK implementation\n" );
	sb.append( " * @details AUTO-GENERATED FILE - DO NOT EDIT - " );
	std::format_to( std::back_inserter( sb ), "Generated by: VisVersionsGenerator (vista-sdk-cpp v{})\n", sdkVersion );
	sb.append( " */\n" );
	sb.append( "\n" );

	// Includes
	sb.append( "#pragma once\n\n" );
	sb.append( "#include \"dnv/vista/sdk/VisVersions.h\"\n\n" );
	sb.append( "#include <array>\n\n" );
	sb.append( "namespace dnv::vista::sdk\n" );
	sb.append( "{\n" );

	// VisVersions namespace
	sb.append( "/**\n" );
	sb.append( " * @brief Internal VIS version utilities\n" );
	sb.append( " * @note For internal SDK use only\n" );
	sb.append( " */\n" );
	sb.append( "namespace VisVersions\n" );
	sb.append( "{\n" );

	// All versions array
	sb.append( "/**\n" );
	sb.append( " * @brief Array of all VIS versions enum values\n" );
	sb.append( " * @return Array containing all VIS version enum values\n" );
	sb.append( " */\n" );
	std::format_to( std::back_inserter( sb ), "constexpr std::array<VisVersion, {}> all()\n", versions.size() );
	sb.append( "{\n" );
	sb.append( "return {\n" );
	for ( size_t i = 0; i < versions.size(); ++i )
	{
		std::string enumName = versions[i];
		std::replace( enumName.begin(), enumName.end(), '-', '_' );
		std::format_to( std::back_inserter( sb ), "VisVersion::v{},\n", enumName );
	}
	sb.append( "};\n" );
	sb.append( "}\n" );

	// latest function
	sb.append( "/**\n" );
	sb.append( " * @brief Get the latest available VIS version\n" );
	sb.append( " * @return The latest VIS version\n" );
	sb.append( " */\n" );
	sb.append( "constexpr VisVersion latest() noexcept\n" );
	sb.append( "{\n" );
	sb.append( "constexpr auto versions = all();\n" );
	sb.append( "return versions.back();\n" );
	sb.append( "}\n" );

	// isValid function
	sb.append( "/**\n" );
	sb.append( " * @brief Check if a VisVersion is valid\n" );
	sb.append( " * @param version The version to check\n" );
	sb.append( " * @return true if valid, false otherwise\n" );
	sb.append( " */\n" );
	sb.append( "constexpr bool isValid( VisVersion version )\n" );
	sb.append( "{\n" );
	sb.append( "switch ( version )\n" );
	sb.append( "{\n" );
	for ( const auto& version : versions )
	{
		std::string enumName = version;
		std::replace( enumName.begin(), enumName.end(), '-', '_' );
		std::format_to( std::back_inserter( sb ), "case VisVersion::v{}:\n", enumName );
	}
	sb.append( "return true;\n" );
	sb.append( "default:\n" );
	sb.append( "return false;\n" );
	sb.append( "}\n" );
	sb.append( "}\n" );

	// close namespaces
	sb.append( "} // namespace VisVersions\n" );
	sb.append( "} // namespace dnv::vista::sdk\n" );

	std::ofstream outputFile( outputPath, std::ios::binary );
	if ( !outputFile )
	{
		fprintf( stderr, "Failed to open output file: %s\n", outputPath.string().c_str() );
		return false;
	}

	outputFile.write( sb.data(), static_cast<std::streamsize>( sb.size() ) );

	if ( !outputFile )
	{
		fprintf( stderr, "Failed to write to output file: %s\n", outputPath.string().c_str() );
		return false;
	}

	return true;
}

int main( int argc, char* argv[] )
{
	if ( argc < 4 )
	{
		fprintf( stderr, "Usage: VisVersionsGenerator <public_header_path> <extensions_header_path> <sdk_version>\n" );
		return 1;
	}

	fs::path visVersionHeaderPath = argv[1];
	fs::path visVersionExtensionsPath = argv[2];
	std::string_view sdkVersion = argv[3];

	printf( "Loading VIS versions from embedded resources...\n" );

	auto versions = EmbeddedResource::visVersions();

	if ( versions.empty() )
	{
		fprintf( stderr, "No VIS versions found!\n" );
		return 1;
	}

	printf( "Found %zu VIS versions:\n", versions.size() );
	for ( const auto& version : versions )
	{
		printf( "  - %s\n", version.c_str() );
	}

	printf( "Generating public header: %s\n", visVersionHeaderPath.string().c_str() );

	if ( !generateVisVersionHeader( versions, visVersionHeaderPath, sdkVersion ) )
	{
		return 1;
	}

	printf( "Generating extensions header: %s\n", visVersionExtensionsPath.string().c_str() );

	if ( !generateVisVersionExtensionsHeader( versions, visVersionExtensionsPath, sdkVersion ) )
	{
		return 1;
	}

	return 0;
}
